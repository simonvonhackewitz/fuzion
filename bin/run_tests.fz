# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code run_tests script
#
# -----------------------------------------------------------------------


########### Extensions ###############

# stores the results of a process
#
process_result(out String, err String, exit_code u32) is

# specified environment variables as key,value array
#
envir_var_kv := [
  "PATH",
  "LANG",
  "JAVA_HOME",
  "POSTCONDITIONS",
  "PRECONDITIONS",
  "dev_flang_tools_serializeFUIR"
].map k->
  (envir.vars.get k).bind v->
    (k,v)
 .filter o->o.ok
 .map o->o.val
 .as_array

# envir vars as map
#
envir_vars :=
  (container.ordered_map
    (envir_var_kv
      .map x->x.0
      .as_array)
    (envir_var_kv
      .map x->x.1
      .as_array))

# helper to get out, err, exit_code from started process
#
record_process(p os.process,
      # the command, for error messages
      cmd String) process_result =>
  lm : mutate is
  lm ! ()->
    match p.with_out String lm (()->String.from_bytes (io.buffered lm).read_fully)
      e error => panic "failed reading stdout from $cmd, error is: $e"
      out String =>
        match p.with_err String lm (()->String.from_bytes (io.buffered lm).read_fully)
          e error => panic "failed reading stderr from $cmd, error is: $e"
          err String =>
            match p.wait
              e error => panic "failed waiting for $cmd, error is: $e"
              ec u32 => process_result out err ec

# execute this Sequence of process+args
# return what we read from stdout as the result
#
Sequence.prefix ! =>
  seq := map x->x.as_string
  match os.process.start seq.first.val (seq.drop 1) envir_vars
    e error => panic "failed executing {Sequence.this}, error is $e"
    p os.process => record_process p Sequence.this.as_string


# feed this string to a new process
# return what we read from stdout as the result
#
String.infix | (seq Sequence String) =>

  lm : mutate is
  lm ! ()->
    match os.process.start seq.first.val (seq.drop 1) envir_vars
      e error => panic "failed executing $seq, error is $e"
      p os.process =>
        _ := p.with_in unit lm ()->
          # NYI: ambiguous result type:
          # _ := write_to lm
          _ := (io.buffered lm).writer.env.write String.this.utf8
          _ := (io.buffered lm).writer.env.flush
          _ := p.close_in
        record_process p seq.as_string


# execute this string by splitting at all whitespaces
# return what we read from stdout as the result
#
String.prefix !! =>
  !split


# NYI: UNDER DEVELOPMENT: what about thread safety?
append_line(dest String, str String) =>
  lm : mutate is
  lm ! ()->
    check (io.file.use unit lm $dest io.file.mode.append ()->
             check ("$str\n".write_to lm).ok).ok


# read file f fully
#
read_file_fully(f String) outcome String =>
  lm : mutate is
  lm ! ()->
    io.file.use _ lm f io.file.mode.read ()->
      String.from_bytes (io.buffered lm).read_fully


########### run_tests ###############


main =>

  # NYI: UNDER DEVELOPMENT: react to Ctrl+c like in bash scripts (trap)

  if (envir.args.count != 3 && envir.args.count != 4)
    say "wrong argument count"
    say "usage:"
    say "run_tests.fz <build_dir> <target> [<n_threads>]"
    exit 1

  build_dir := envir.args[1]
  target := envir.args[2]


  # source: https://stackoverflow.com/questions/45181115/portable-way-to-find-the-number-of-processors-cpus-in-a-shell-script
  # first, try third arg then try a few executables, if everything fails use default value
  tc :=
    (fuzion.runtime.contract_fault.try ()->(envir.args.nth 3).val.trim.parse_i32.val)
      .catch _->
        (fuzion.runtime.contract_fault.try ()->(!!"nproc --all").out.trim.parse_i32.val)
          .catch _->
            (fuzion.runtime.contract_fault.try ()->(!!"getconf _NPROCESSORS_ONLN").out.trim.parse_i32.val)
              .catch _->
                (fuzion.runtime.contract_fault.try ()->(!!"sysctl -n hw.ncpu").out.trim.parse_i32.val)
                  .catch _->4
  thread_count := tc > 6 ? 6 : tc


  # NYI: port to fuzion
  tests := (((!!"find $build_dir/tests -name Makefile -print0").out | ["xargs", "--null", "--max-args=1", "dirname"]).out | ["sort"])
    .out
    .lines

  results := "$build_dir/run_tests.results"
  failures := "$build_dir/run_tests.failures"

  _ := io.file.delete results
  _ := io.file.delete failures

  say "{tests.count} tests, running $thread_count tests in parallel."

  start_time_total := time.nano.read

  _ := concur.thread_pool thread_count ()->
    for test in tests do
      check concur.thread_pool.env.submit ()->
        if io.file.exists "$test/skip" || io.file.exists "$test/skip_$target"
          yak "_"
          append_line results "$test: skipped"
        else

          start_time := time.nano.read
          res := !!"timeout --kill-after=600s 600s make $target --environment-overrides --directory=$test"
          end_time := time.nano.read

          if res.exit_code = 0 then
            yak "."
            append_line results "$test in {end_time-start_time}: ok"
          else
            yak "#"
            append_line results "$test in {end_time-start_time}: failed"
            append_line failures res.out
            append_line failures res.err

  end_time_total := time.nano.read

  results_content := read_file_fully results
    .val

  (ok, skipped, failed) := results_content
    .lines
    .reduce (0,0,0) (r, t)->
      if t.ends_with "ok"
        (r.0+1, r.1, r.2)
      else if t.ends_with "skipped"
        (r.0, r.1+1, r.2)
      else if t.ends_with "failed"
        (r.0, r.1, r.2+1)
      else
        r

  say ""
  say "$ok/{tests.count} tests passed, $skipped skipped, $failed failed in {(end_time_total-start_time_total).as_string.trim}."

  if failed > 0
    say "Failed tests:"

    results_content
      .lines
      .for_each t->
        if t.ends_with "failed"
          say t

    say "============= run_tests.failures START ============="
    say (read_file_fully failures)
    say "============= run_tests.failures END ============="

    # NYI: UNDER DEVELOPMENT: add rerun command like in bash scripts

    exit 1

_ := main
