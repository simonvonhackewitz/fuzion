# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion standard library feature percent
#
# -----------------------------------------------------------------------

# Percent (url) encoding and decoding as specified in RFC 3986 section 2.1
#
# * The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the same.
# * The special characters "-", ".", "_", and "~" remain the same.
# * All other characters are unsafe and get converted.
#
public percent is

  # NYI: UNDER DEVELOPMENT: add encoding with space as "+" ?
  # NYI: UNDER DEVELOPMENT: add encoding to application/x-www-form-urlencoded MIME format ?


  # is this the value of an ascii character that is considered safe (unreserved) according to RFC 3986 section 2.3
  u32.safe_chr =>
    ("A".val <= val <= "Z".val || "a".val <= val <= "z".val || "0".val <= val <= "9".val
     || val = "-".val || val = ".".val || val = "_".val || val = "~".val)


  # Percent encode (url encode) a Sequence of bytes, as specified in RFC 3986 section 2.1
  #
  # * Bytes values of a save (unreserved) character (A-Z, a-z, 0-9, "-", ".", "_" and "~") are encoded as that character.
  # * All other values are encoded as "%HH", where HH is the hexadecimal representation of the byte, using uppercase letters
  #
  public encode_bytes(data Sequence u8) String =>
    data.map b->(b.as_u32.safe_chr ? (codepoint b.as_u32) : ("%" + b.as_string 16 .upper_case))
        .as_string ""


  # Percent encode (url encode) an utf8 string, as specified in RFC 3986 section 2.1
  #
  # * The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9" remain the same.
  # * The special characters "-", ".", "_", and "~" remain the same.
  # * All other characters are unsafe, their bytes are individually converted to a 3-character string "%HH",
  #   where HH is the two-digit hexadecimal representation of the byte. This also applies to the space character.
  #
  public encode_str(str String) String => encode_bytes str.utf8


  # Decode a percent encoded (url encoded) utf8 string
  #
  # * Percent encoded bytes ("%HH" where HH is the two-digit hexadecimal representation of the byte),
  #   or sequences of those, are converted to the corresponding codepoint(s) in utf8
  # * The plus character "+" is converted to a space " ".
  #
  public decode_as_str(enc_utf8 String) outcome String
  # NYI: CLEANUP: does this restriction make sense? Should non ascii characters be allowed? Decoding works without it
  # pre debug: enc_str.as_codepoints ∀ v-> ("A" <= v <= "Z" || "a" <= v <= "z"
  #               || "0" <= v <= "9" || v = "-" || v = "." || v = "_" || v = "~" || v = "%" || v = "+")
  =>
    enc := enc_utf8.as_codepoints
    len := enc.count
    dec(res String, i i32) outcome String =>
      if i >= len
        res
      else if enc[i] != "%"
        dec (res + (enc[i] = "+" ? " " : enc[i])) i+1
      else
        # decode percent encoded characters, for multi-byte codepoints each byte is individually percent encoded
        for bytes := outcome (Sequence u8) (id (Sequence u8) []), new_bytes
            j := i, j+3
        while j < len && enc[j] = "%"
          new_bytes outcome (Sequence u8) :=
            if j+3 > len
              error "unexpected end of input, expected two hex characters after '%' at position $j"
            else
              match encodings.base16.decode_str (enc_utf8.substring_codepoint j+1 j+3).upper_case
                b array u8 => bytes.val ++ b
                e error => error "broken string, failed to decode '{enc_utf8.substring_codepoint j j+3}' at position $j"
        until !new_bytes.ok
          new_bytes.err
        else
          dec (res + String.from_bytes bytes.val) j
    dec "" 0


  # Decode a percent encoded (url encoded) string into a sequence of bytes
  #
  # * The alphanumeric characters "a" through "z", "A" through "Z" and "0" through "9",
  #   as well as the special characters "-", ".", "_", and "~" are converted to the corresponding ascii value.
  # * Percent encoded bytes ("%xy") are simply converted to a byte.
  # * The plus character "+" is converted to the ascii value of the space character " ".
  #
  public decode_as_bytes(enc_str String) outcome (Sequence u8)
  pre debug: enc_str.as_codepoints ∀ v-> ("A" <= v <= "Z" || "a" <= v <= "z"
                || "0" <= v <= "9" || v = "-" || v = "." || v = "_" || v = "~" || v = "%" || v = "+")
  =>
    enc := enc_str.utf8
    len := enc.count
    dec(res Sequence u8, i i32) outcome (Sequence u8) =>
      if i >= len
        res
      else if enc[i].as_u32 != "%".val
        dec (res ++ (enc[i].as_u32 = "+".val ? [" ".val.as_u8] : [enc[i]])) i+1
      else
        # decode percent encoded characters, for multi-byte codepoints each byte is individually percent encoded
        for bytes := outcome (Sequence u8) (id (Sequence u8) []), new_bytes
            j := i, j+3
        while j < len && enc[j].as_u32 = "%".val
          new_bytes outcome (Sequence u8) :=
            if j+3 > len
              error "unexpected end of input, expected two hex characters after '%' at position $j"
            else
              match encodings.base16.decode_str (enc_str.substring_codepoint j+1 j+3).upper_case
                b array u8 => bytes.val ++ b
                e error => error "broken string, failed to decode '{enc_str.substring j j+3}' at position $j"
        until !new_bytes.ok
          new_bytes.err
        else
          dec (res ++ bytes.val) j
    dec "".utf8 0

    # NYI: CLEANUP: merge/unify decode versions?
