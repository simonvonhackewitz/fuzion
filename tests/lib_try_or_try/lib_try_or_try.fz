# This file is part of the Fuzion language implementation.
#
# The Fuzion language implementation is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License as published
# by the Free Software Foundation, version 3 of the License.
#
# The Fuzion language implementation is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
# License for more details.
#
# You should have received a copy of the GNU General Public License along with The
# Fuzion language implementation.  If not, see <https://www.gnu.org/licenses/>.


# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion test lib_try_or_try
#
# -----------------------------------------------------------------------


# I first implemented or_try like this, but it contains a subtle bug:
# ```
# or_try(alt ERROR->T) try ERROR F T =>
#     try ERROR F _ ()->
#       catch alt
# ```
# To understand why we need to look at catch:
# ```
# catch(code_catch ERROR->T) T =>
#     lm ! ()->
#           m := lm.env.new (option ERROR nil)
#           v := F.new e->
#               m <- e
#               F.abort
#           F.instate T v code_try (_ -> code_catch m.get.get)
# ```
# and some example code
# ```
#    fuzion.runtime.contract_fault
#      .try ()->(envir.args.nth 3).val.trim.parse_i32.val
#      .or_try _->(envir.vars.get "DEBUG_LEVEL").val.trim.parse_i32.val
#      .catch  _->4
# ```

#  1) the catch of the try returned from `or_try` would first instatiate an lm. lets called it lm_1.
#  2) the code of the catch calls the catch of the original try, this instantiates another lm, lets call it lm_2.
#  3) code of the original try fails, writing to `m <- e`, m was created from lm_2, so all is good
#  4) code_catch m.get.get is now executed, this code also fails, also writing to m via `m <- e` but this m was created from lm_1 while lm_2 is still instated => we get an invalid mutate error.


# To work around this I introduced a `catch0` that uses the already instated `lm` and used this in `or_try`

x :=
  fuzion.runtime.contract_fault
    .try ()->(envir.args.nth 3).val.trim.parse_i32.val
    .or_try _->(say "failed envir args";(envir.vars.get "DEBUG_LEVEL").val.trim.parse_i32.val)
    .catch  _->(say "failed envir vars";4)

say x

